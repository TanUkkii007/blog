# Akkaはマルチスレッドプログラミングにおける可視性の問題をどう解決しているか

アクターのロケーション透過性は、アクターがどのサーバー、どのCPUコア、どのスレッド上で実行されようが同じ挙動になることを保証する。これはプログラマがアクターの実行環境を意識しなくていいという点ですばらしい。この性質により僕のような並列プログラミングや分散システムにそんなに詳しくない開発者でも安全に並列分散システムのコードを書くことができている。

アクターが並列プログラミングを簡単にするもう１つの特性はカプセル化である。アクターは内部にミュータブルな状態をもつことができ、それを安全に更新することができる。つまりvarを使うことができる。ここでもプログラマは並列環境で実行されていることを意識する必要はない。アクターの強いカプセル化は内部状態を外からのアクセスから守ってくれる。

もしプログラマが並列環境を意識しなくてはいけなかったら、このアクター内のvarは@volatile宣言がされてなければいけない。なぜならあるスレッドでのvarの変更は別のスレッドで見えているとは限らないからだ。varの値の変更があるCPU上のスレッドでなされた場合、その変更を別のCPUが観測するにはそのCPUのローカルキャッシュを更新する必要がある。これにはしばらく時間がかかる。volatile変数の場合、他のスレッド書き込んだ変数の値は必ず他のスレッドにも伝播しているよう保証してくれる。

ここでの疑問は、プログラマが@volatile宣言をしなくてもいいようにAkkaがどのような工夫をしているかということだ。Akkaがロケーション透過性を実現するには、アクター内部の@volatile宣言のないvarの書き込みが次のメッセージを受信したときの実行スレッドで観測できている必要がある。

その答えは[StackOverflow](http://stackoverflow.com/questions/15849366/how-does-akka-implement-the-jmm-like-happens-before-relationship)でAkkaのコントリビューターであるRoland Kuhnさんが答えていた。

Akkaの[Java Memory Model](http://doc.akka.io/docs/akka/2.4.7/general/jmm.html#Actors_and_the_Java_Memory_Model)のドキュメントにあるように、Akkaは可視性と順序問題に対し２つの"happens before"ルールを保証しています。

- The actor send rule: アクターへのメッセージ送信は、そのアクターがそのメッセージを受信する前に起きる
- The actor subsequent processing rule: アクターでのあるメッセージの処理は、そのアクターでの次のメッセージの前に起こる


僕は@yoskhdiaさんに質問されるまで@volatile